Моё окружение:
Я использую стандартную db postgres, которая поднята на 6543 порту, имеет следующую схему данных:
    person_name: str
    period_life: str
    years_life: str
    school_teaching: str
    person_teacher: str
    person_followers: str
    person_works: str
    short_description: str
    full_description: str
    create_data: datetime
    update_data: datetime
У меня backend на fastapi, методы - GET, POST, PUT, DELL уже написаны, на беке ничего писать не нужно, как фронтенд я использую react.
Напиши мне модуль, который располагается в /components/spider_data.js.
Модуль должен иметь следующий функционал:
1. Ты должен в реальном времени асинхронно отображать данные по колонкам 
person_name 
years_life
school_teaching
2. Визуализация всех данных должна быть в виде паутины, где серединой паутины (должно быть красиво всё и в кружочке) будет как раз 3 колонки описанные в пунке 1 выше. 
3. Нужно реализовать механизм зума на странице для перемещения по области где будет паутина с авторами, а так же чтобы я с помощью зажима мышки мог перемещаться по области где есть паутина с авторами.
4. Нужно реализовать ещё механизм связи этих кружочков, если эти кружочки имеет одинаковое значение по полю school_teaching, то эти центры у паутины должны быть связаны. один элемент с другим. 
5. Нужно реализовать механизм создания центров паутины с обязательными полями для отправки в бд:
person_name 
years_life
school_teaching
Не обязательные поля:
period_life
years_life
person_teacher
person_followers
person_works
short_description
full_description
Где после создания асинхронно после отработки 1 пункта я получал бы обновление на моём рабочем поле со всеми паутинами


Вот мой CenterDetailsModal.js
import React from 'react';

const CenterDetailsModal = ({ center, onClose }) => {
  if (!center) return null;

  return (
    <div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 1000,
    }}>
      <div style={{
        backgroundColor: '#fff',
        padding: '20px',
        borderRadius: '5px',
        width: '300px',
        maxHeight: '80vh',
        overflowY: 'auto',
        position: 'relative', // Для позиционирования крестика
      }}>
        {/* Крестик для закрытия */}
        <button
          onClick={onClose}
          style={{
            position: 'absolute',
            top: '10px',
            right: '10px',
            background: 'none',
            border: 'none',
            fontSize: '16px',
            cursor: 'pointer',
          }}
        >
          ×
        </button>

        <h3>Данные центра</h3>
        <p><strong>Имя персонажа:</strong> {center.person_name}</p>
        <p><strong>Период жизни:</strong> {center.period_life}</p>
        <p><strong>Годы жизни:</strong> {center.years_life}</p>
        <p><strong>Школа обучения:</strong> {center.school_teaching}</p>
        <p><strong>Учитель:</strong> {center.person_teacher}</p>
        <p><strong>Последователи:</strong> {center.person_followers}</p>
        <p><strong>Работы:</strong> {center.person_works}</p>
        <p><strong>Краткое описание:</strong> {center.short_description}</p>
        <p><strong>Полное описание:</strong> {center.full_description}</p>
      </div>
    </div>
  );
};

export default CenterDetailsModal;
CreateCenterForm.js
import React, { useState } from 'react';

const CreateCenterForm = ({ onSubmit }) => {
  const [formData, setFormData] = useState({
    person_name: '',
    years_life: '',
    school_teaching: '',
    period_life: '',
    person_teacher: '',
    person_followers: '',
    person_works: '',
    short_description: '',
    full_description: '',
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({ ...formData, [name]: value });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit(formData);
  };

  return (
    <form onSubmit={handleSubmit} style={{ padding: '20px', border: '1px solid #ccc', borderRadius: '5px' }}>
      <h3>Создать новый центр</h3>
      <div>
        <label>Имя персонажа:</label>
        <input
          type="text"
          name="person_name"
          value={formData.person_name}
          onChange={handleChange}
          required
        />
      </div>
      <div>
        <label>Годы жизни:</label>
        <input
          type="text"
          name="years_life"
          value={formData.years_life}
          onChange={handleChange}
          required
        />
      </div>
      <div>
        <label>Школа обучения:</label>
        <input
          type="text"
          name="school_teaching"
          value={formData.school_teaching}
          onChange={handleChange}
          required
        />
      </div>
      {/* Опциональные поля */}
      <div>
        <label>Период жизни:</label>
        <input
          type="text"
          name="period_life"
          value={formData.period_life}
          onChange={handleChange}
        />
      </div>
      <div>
        <label>Учитель:</label>
        <input
          type="text"
          name="person_teacher"
          value={formData.person_teacher}
          onChange={handleChange}
        />
      </div>
      <button type="submit">Создать</button>
    </form>
  );
};

export default CreateCenterForm;
SpiderData.js
import React, { useState, useEffect } from 'react';
import { TransformWrapper, TransformComponent } from 'react-zoom-pan-pinch';
import SpiderWeb from './SpiderWeb';
import CreateCenterForm from './CreateCenterForm';
import CenterDetailsModal from './CenterDetailsModal';

const SpiderData = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [selectedCenter, setSelectedCenter] = useState(null);

  useEffect(() => {
    console.log('Загрузка данных с сервера...');
    fetch('http://localhost:9000/data/api/')
      .then((res) => {
        if (!res.ok) {
          throw new Error('Ошибка при загрузке данных');
        }
        return res.json();
      })
      .then((response) => {
        console.log('Данные получены:', response);
        const rawData = response.objects;

        if (Array.isArray(rawData)) {
          const processedData = rawData
            .filter((item) => item.person_name !== 'string')
            .map((item, index, array) => ({
              ...item,
              x: 400 + Math.cos((index / array.length) * 2 * Math.PI) * 300,
              y: 400 + Math.sin((index / array.length) * 2 * Math.PI) * 300,
            }));
          console.log('Обработанные данные:', processedData);
          setData(processedData);
        } else {
          throw new Error('Данные не являются массивом');
        }
      })
      .catch((err) => {
        console.error('Ошибка при загрузке данных:', err);
        setError(err.message);
      })
      .finally(() => {
        setLoading(false);
      });
  }, []);

  const handleCreateCenter = (newCenter) => {
    console.log('Создание нового центра:', newCenter);
    fetch('http://localhost:9000/data/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(newCenter),
    })
      .then((res) => res.json())
      .then((newItem) => {
        console.log('Новый центр создан:', newItem);
        const newData = [
          ...data,
          {
            ...newItem,
            x: 400 + Math.cos((data.length / (data.length + 1)) * 2 * Math.PI) * 300,
            y: 400 + Math.sin((data.length / (data.length + 1)) * 2 * Math.PI) * 300,
          },
        ];
        setData(newData);
      })
      .catch((err) => {
        console.error('Ошибка при создании центра:', err);
        setError(err.message);
      });
  };

  const handleCenterClick = (center) => {
    console.log('Выбран центр:', center);
    alert(`Выбран центр: ${center.person_name}`);
  };

  const handleCenterDoubleClick = (center) => {
    console.log('Двойной клик на центр:', center);
    setSelectedCenter(center);
  };

  const handleCloseModal = () => {
    setSelectedCenter(null);
  };

  if (loading) {
    return <div>Загрузка...</div>;
  }

  if (error) {
    return <div>Ошибка: {error}</div>;
  }

  return (
    <div style={{ display: 'flex', height: '100vh' }}>
      <div style={{ flex: 1, position: 'relative' }}>
        <TransformWrapper>
          <TransformComponent>
            <SpiderWeb
              data={data}
              onCenterClick={handleCenterClick}
              onCenterDoubleClick={handleCenterDoubleClick}
            />
          </TransformComponent>
        </TransformWrapper>
      </div>
      <div style={{ width: '300px', padding: '20px' }}>
        <CreateCenterForm onSubmit={handleCreateCenter} />
      </div>
      {selectedCenter && (
        <CenterDetailsModal center={selectedCenter} onClose={handleCloseModal} />
      )}
    </div>
  );
};

export default SpiderData;
SpiderWeb.js
import React, { useEffect, useRef } from 'react';
import Sigma from 'sigma';
import { Graph } from 'graphology';
import forceAtlas2 from 'graphology-layout-forceatlas2';

const SpiderWeb = ({ data, onCenterClick }) => {
  const containerRef = useRef(null);

  useEffect(() => {
    if (!data.length) return;

    // Создаем граф
    const graph = new Graph();

    // Добавляем узлы
    data.forEach((item) => {
      graph.addNode(item.id, {
        label: item.person_name,
        x: item.x,
        y: item.y,
        size: 10,
        color: getColorBySchool(item.school_teaching),
      });
    });

    // Добавляем ребра
    const schoolMap = {};
    data.forEach((item) => {
      if (!schoolMap[item.school_teaching]) {
        schoolMap[item.school_teaching] = [];
      }
      schoolMap[item.school_teaching].push(item.id);
    });

    Object.values(schoolMap).forEach((group) => {
      if (group.length > 1) {
        for (let i = 0; i < group.length - 1; i++) {
          for (let j = i + 1; j < group.length; j++) {
            graph.addEdge(group[i], group[j], {
              color: '#ccc',
            });
          }
        }
      }
    });

    // Инициализируем Sigma
    const sigmaInstance = new Sigma(graph, containerRef.current);

    // Применяем ForceAtlas2 layout
    const settings = forceAtlas2.inferSettings(graph);
    forceAtlas2.assign(graph, { settings, iterations: 50 });

    // Обработка клика на узел
    sigmaInstance.on('clickNode', (event) => {
      const nodeId = event.data.node;
      const node = data.find((item) => item.id === nodeId);
      if (node) onCenterClick(node);
    });

    return () => {
      sigmaInstance.kill();
    };
  }, [data, onCenterClick]);

  const getColorBySchool = (school) => {
    const colors = ['#FF6F61', '#6B5B95', '#88B04B', '#F7CAC9', '#92A8D1'];
    const index = school?.length % colors.length || 0;
    return colors[index];
  };

  return <div ref={containerRef} style={{ width: '100%', height: '100%', border: '1px solid #ccc' }} />;
};

export default SpiderWeb;

У меня теперь не оображаются центры, дополни мой код изменения по модальному окну который ты описал до этого и праверь его на правильность, если есть возможность, оптимизируй его.
Вот мой App.js
import React from 'react';
import SpiderData from './components/SpiderData';

const App = () => {
  return (
    <div>
      <SpiderData />
    </div>
  );
};

export default App;