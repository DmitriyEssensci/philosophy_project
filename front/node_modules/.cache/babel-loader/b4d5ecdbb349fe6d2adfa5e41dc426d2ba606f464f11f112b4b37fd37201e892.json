{"ast":null,"code":"var _jsxFileName = \"/home/dmitriyessensci/me/philosophy_project/front/src/components/SpiderWeb.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport Sigma from 'sigma';\nimport { Graph } from 'graphology';\nimport forceAtlas2 from 'graphology-layout-forceatlas2';\nimport { EdgeArrowProgram } from 'sigma/rendering';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SpiderWeb = ({\n  data,\n  onCenterClick,\n  onCenterDoubleClick\n}) => {\n  _s();\n  const containerRef = useRef(null);\n  const [dimensions, setDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const hoverTimeoutRef = useRef(null); // Для хранения таймера задержки\n  const sigmaInstanceRef = useRef(null); // Для хранения экземпляра Sigma\n  const graphRef = useRef(null); // Для хранения графа\n  const selectedNodeRef = useRef(null); // Для хранения выбранного узла\n\n  useEffect(() => {\n    if (!data.length) return;\n    const graph = new Graph({\n      multi: true\n    }); // Создаём мультиграф\n    graphRef.current = graph; // Сохраняем граф в ref\n\n    // Добавляем узлы\n    data.forEach(item => {\n      graph.addNode(item.id.toString(), {\n        label: item.person_name,\n        x: item.x,\n        y: item.y,\n        size: 5,\n        color: getColorBySchool(item.person_name),\n        // Динамический цвет на основе имени\n        highlighted: false // Добавляем атрибут для подсветки\n      });\n    });\n\n    // Функция для разбиения строки на массив имён\n    const splitNames = names => {\n      if (!names) return [];\n      return names.split(',').map(name => name.trim().toLowerCase());\n    };\n\n    // Функция для получения части строки до запятой\n    const getNameBeforeComma = name => {\n      return name.split(',')[0].trim().toLowerCase();\n    };\n\n    // Добавляем рёбра на основе influenced_by и influenced\n    data.forEach(sourceItem => {\n      const sourceId = sourceItem.id.toString();\n      const sourceName = getNameBeforeComma(sourceItem.person_name); // Берём часть до запятой\n\n      data.forEach(targetItem => {\n        const targetId = targetItem.id.toString();\n\n        // Обрабатываем influenced_by (фиолетовые рёбра)\n        if (targetItem.influenced_by) {\n          const influencedByNames = splitNames(targetItem.influenced_by);\n          if (influencedByNames.some(name => getNameBeforeComma(name) === sourceName)) {\n            graph.addEdge(sourceId, targetId, {\n              color: '#800080',\n              type: 'arrow',\n              // Добавляем тип стрелочки\n              size: 0.5,\n              // Толщина ребра\n              highlighted: false // Добавляем атрибут для подсветки\n            });\n          }\n        }\n\n        // Обрабатываем influenced (зелёные рёбра)\n        if (targetItem.influenced) {\n          const influencedNames = splitNames(targetItem.influenced);\n          if (influencedNames.some(name => getNameBeforeComma(name) === sourceName)) {\n            graph.addEdge(targetId, sourceId, {\n              color: '#008000',\n              type: 'arrow',\n              // Добавляем тип стрелочки\n              size: 0.5,\n              // Толщина ребра\n              highlighted: false // Добавляем атрибут для подсветки\n            });\n          }\n        }\n      });\n    });\n\n    // Динамическое изменение размера узлов в зависимости от количества связей\n    graph.forEachNode(node => {\n      const degree = graph.degree(node);\n      graph.setNodeAttribute(node, 'size', Math.log(degree + 1) * 3); // Уменьшаем размер узлов\n    });\n\n    // Инициализируем Sigma с поддержкой стрелочек\n    const sigmaInstance = new Sigma(graph, containerRef.current, {\n      renderEdgeLabels: false,\n      enableEdgeHoverEvents: true,\n      enableEdgeClickEvents: false,\n      edgeProgramClasses: {\n        arrow: EdgeArrowProgram // Используем программу для отрисовки стрелочек\n      }\n    });\n    sigmaInstanceRef.current = sigmaInstance; // Сохраняем экземпляр Sigma\n\n    // Настройка ForceAtlas2\n    const settings = forceAtlas2.inferSettings(graph);\n    settings.adjustSizes = true; // Учитываем размеры узлов\n    settings.scalingRatio = 50; // Увеличиваем масштаб\n    settings.gravity = 0.01; // Уменьшаем гравитацию для более равномерного распределения\n    settings.strongGravityMode = false; // Включаем сильную гравитацию\n\n    // Применяем ForceAtlas2 для динамического расположения узлов\n    forceAtlas2.assign(graph, {\n      settings,\n      iterations: 1000\n    }); // Увеличиваем количество итераций\n\n    // Обработка событий\n    sigmaInstance.on('clickNode', event => {\n      const node = event.node;\n      selectedNodeRef.current = node; // Сохраняем выбранный узел\n\n      // Выделяем связи и зависимые центры\n      const neighbors = graph.neighbors(node);\n      const edges = graph.edges(node);\n\n      // Затемняем все узлы и рёбра\n      graph.forEachNode(n => {\n        graph.setNodeAttribute(n, 'hidden', true);\n      });\n      graph.forEachEdge(e => {\n        graph.setEdgeAttribute(e, 'hidden', true);\n      });\n\n      // Подсвечиваем узел и его соседей\n      graph.setNodeAttribute(node, 'hidden', false);\n      graph.setNodeAttribute(node, 'highlighted', true);\n      neighbors.forEach(neighbor => {\n        graph.setNodeAttribute(neighbor, 'hidden', false);\n        graph.setNodeAttribute(neighbor, 'highlighted', true);\n      });\n\n      // Подсвечиваем рёбра\n      edges.forEach(edge => {\n        graph.setEdgeAttribute(edge, 'hidden', false);\n        graph.setEdgeAttribute(edge, 'highlighted', true);\n      });\n      sigmaInstance.refresh();\n    });\n    sigmaInstance.on('doubleClickNode', event => {\n      event.preventSigmaDefault();\n      const node = data.find(item => item.id.toString() === event.node);\n      if (node) onCenterDoubleClick(node);\n    });\n\n    // Выделение связей при наведении на узел с задержкой\n    sigmaInstance.on('enterNode', event => {\n      // Очищаем предыдущий таймер\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n      }\n\n      // Устанавливаем новый таймер\n      hoverTimeoutRef.current = setTimeout(() => {\n        const node = event.node;\n        const neighbors = graph.neighbors(node);\n        const edges = graph.edges(node);\n\n        // Затемняем все узлы и рёбра\n        graph.forEachNode(n => {\n          graph.setNodeAttribute(n, 'hidden', true);\n        });\n        graph.forEachEdge(e => {\n          graph.setEdgeAttribute(e, 'hidden', true);\n        });\n\n        // Подсвечиваем узел и его соседей\n        graph.setNodeAttribute(node, 'hidden', false);\n        graph.setNodeAttribute(node, 'highlighted', true);\n        neighbors.forEach(neighbor => {\n          graph.setNodeAttribute(neighbor, 'hidden', false);\n          graph.setNodeAttribute(neighbor, 'highlighted', true);\n        });\n\n        // Подсвечиваем рёбра\n        edges.forEach(edge => {\n          graph.setEdgeAttribute(edge, 'hidden', false);\n          graph.setEdgeAttribute(edge, 'highlighted', true);\n        });\n        sigmaInstance.refresh();\n      }, 300); // Задержка 300 мс\n    });\n\n    // Сброс выделения при уходе с узла\n    sigmaInstance.on('leaveNode', event => {\n      // Очищаем таймер\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n      }\n\n      // Если узел не выбран, сбрасываем выделение\n      if (!selectedNodeRef.current) {\n        graph.forEachNode(n => {\n          graph.setNodeAttribute(n, 'hidden', false);\n          graph.setNodeAttribute(n, 'highlighted', false);\n        });\n        graph.forEachEdge(e => {\n          graph.setEdgeAttribute(e, 'hidden', false);\n          graph.setEdgeAttribute(e, 'highlighted', false);\n        });\n        sigmaInstance.refresh();\n      }\n    });\n\n    // Обработка клика в пустое пространство\n    sigmaInstance.on('clickStage', () => {\n      // Сбрасываем выделение всех узлов и рёбер\n      selectedNodeRef.current = null; // Сбрасываем выбранный узел\n      graph.forEachNode(n => {\n        graph.setNodeAttribute(n, 'hidden', false);\n        graph.setNodeAttribute(n, 'highlighted', false);\n      });\n      graph.forEachEdge(e => {\n        graph.setEdgeAttribute(e, 'hidden', false);\n        graph.setEdgeAttribute(e, 'highlighted', false);\n      });\n      sigmaInstance.refresh();\n    });\n\n    // Обновляем размеры Sigma при изменении размеров контейнера\n    const resizeObserver = new ResizeObserver(entries => {\n      for (const entry of entries) {\n        const {\n          width,\n          height\n        } = entry.contentRect;\n        setDimensions({\n          width,\n          height\n        });\n        sigmaInstance.refresh();\n      }\n    });\n    if (containerRef.current) {\n      resizeObserver.observe(containerRef.current);\n    }\n    return () => {\n      sigmaInstance.kill();\n      resizeObserver.disconnect();\n      if (hoverTimeoutRef.current) {\n        clearTimeout(hoverTimeoutRef.current);\n      }\n    };\n  }, [data, onCenterClick, onCenterDoubleClick]);\n\n  // Функция для генерации динамического цвета на основе строки\n  const getColorBySchool = school => {\n    const colors = ['#FF6F61', '#6B5B95', '#88B04B', '#F7CAC9', '#92A8D1'];\n    const index = (school === null || school === void 0 ? void 0 : school.length) % colors.length || 0;\n    return colors[index];\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: containerRef,\n      style: {\n        width: '100vw',\n        height: '100vh',\n        border: '1px solid #ccc'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 258,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 257,\n    columnNumber: 5\n  }, this);\n};\n_s(SpiderWeb, \"Z8rA1wDn8mJLvFZYkHSlCZsgXWw=\");\n_c = SpiderWeb;\nexport default _c2 = /*#__PURE__*/React.memo(SpiderWeb);\nvar _c, _c2;\n$RefreshReg$(_c, \"SpiderWeb\");\n$RefreshReg$(_c2, \"%default%\");","map":{"version":3,"names":["React","useEffect","useRef","useState","Sigma","Graph","forceAtlas2","EdgeArrowProgram","jsxDEV","_jsxDEV","SpiderWeb","data","onCenterClick","onCenterDoubleClick","_s","containerRef","dimensions","setDimensions","width","height","hoverTimeoutRef","sigmaInstanceRef","graphRef","selectedNodeRef","length","graph","multi","current","forEach","item","addNode","id","toString","label","person_name","x","y","size","color","getColorBySchool","highlighted","splitNames","names","split","map","name","trim","toLowerCase","getNameBeforeComma","sourceItem","sourceId","sourceName","targetItem","targetId","influenced_by","influencedByNames","some","addEdge","type","influenced","influencedNames","forEachNode","node","degree","setNodeAttribute","Math","log","sigmaInstance","renderEdgeLabels","enableEdgeHoverEvents","enableEdgeClickEvents","edgeProgramClasses","arrow","settings","inferSettings","adjustSizes","scalingRatio","gravity","strongGravityMode","assign","iterations","on","event","neighbors","edges","n","forEachEdge","e","setEdgeAttribute","neighbor","edge","refresh","preventSigmaDefault","find","clearTimeout","setTimeout","resizeObserver","ResizeObserver","entries","entry","contentRect","observe","kill","disconnect","school","colors","index","children","ref","style","border","fileName","_jsxFileName","lineNumber","columnNumber","_c","_c2","memo","$RefreshReg$"],"sources":["/home/dmitriyessensci/me/philosophy_project/front/src/components/SpiderWeb.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport Sigma from 'sigma';\r\nimport { Graph } from 'graphology';\r\nimport forceAtlas2 from 'graphology-layout-forceatlas2';\r\nimport { EdgeArrowProgram } from 'sigma/rendering';\r\n\r\nconst SpiderWeb = ({ data, onCenterClick, onCenterDoubleClick }) => {\r\n  const containerRef = useRef(null);\r\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\r\n  const hoverTimeoutRef = useRef(null); // Для хранения таймера задержки\r\n  const sigmaInstanceRef = useRef(null); // Для хранения экземпляра Sigma\r\n  const graphRef = useRef(null); // Для хранения графа\r\n  const selectedNodeRef = useRef(null); // Для хранения выбранного узла\r\n\r\n  useEffect(() => {\r\n    if (!data.length) return;\r\n\r\n    const graph = new Graph({ multi: true }); // Создаём мультиграф\r\n    graphRef.current = graph; // Сохраняем граф в ref\r\n\r\n    // Добавляем узлы\r\n    data.forEach((item) => {\r\n      graph.addNode(item.id.toString(), {\r\n        label: item.person_name,\r\n        x: item.x,\r\n        y: item.y,\r\n        size: 5,\r\n        color: getColorBySchool(item.person_name), // Динамический цвет на основе имени\r\n        highlighted: false, // Добавляем атрибут для подсветки\r\n      });\r\n    });\r\n\r\n    // Функция для разбиения строки на массив имён\r\n    const splitNames = (names) => {\r\n      if (!names) return [];\r\n      return names.split(',').map((name) => name.trim().toLowerCase());\r\n    };\r\n\r\n    // Функция для получения части строки до запятой\r\n    const getNameBeforeComma = (name) => {\r\n      return name.split(',')[0].trim().toLowerCase();\r\n    };\r\n\r\n    // Добавляем рёбра на основе influenced_by и influenced\r\n    data.forEach((sourceItem) => {\r\n      const sourceId = sourceItem.id.toString();\r\n      const sourceName = getNameBeforeComma(sourceItem.person_name); // Берём часть до запятой\r\n\r\n      data.forEach((targetItem) => {\r\n        const targetId = targetItem.id.toString();\r\n\r\n        // Обрабатываем influenced_by (фиолетовые рёбра)\r\n        if (targetItem.influenced_by) {\r\n          const influencedByNames = splitNames(targetItem.influenced_by);\r\n\r\n          if (influencedByNames.some((name) => getNameBeforeComma(name) === sourceName)) {\r\n            graph.addEdge(sourceId, targetId, {\r\n              color: '#800080',\r\n              type: 'arrow', // Добавляем тип стрелочки\r\n              size: 0.5, // Толщина ребра\r\n              highlighted: false, // Добавляем атрибут для подсветки\r\n            });\r\n          }\r\n        }\r\n\r\n        // Обрабатываем influenced (зелёные рёбра)\r\n        if (targetItem.influenced) {\r\n          const influencedNames = splitNames(targetItem.influenced);\r\n\r\n          if (influencedNames.some((name) => getNameBeforeComma(name) === sourceName)) {\r\n            graph.addEdge(targetId, sourceId, {\r\n              color: '#008000',\r\n              type: 'arrow', // Добавляем тип стрелочки\r\n              size: 0.5, // Толщина ребра\r\n              highlighted: false, // Добавляем атрибут для подсветки\r\n            });\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    // Динамическое изменение размера узлов в зависимости от количества связей\r\n    graph.forEachNode((node) => {\r\n      const degree = graph.degree(node);\r\n      graph.setNodeAttribute(node, 'size', Math.log(degree + 1) * 3); // Уменьшаем размер узлов\r\n    });\r\n\r\n    // Инициализируем Sigma с поддержкой стрелочек\r\n    const sigmaInstance = new Sigma(graph, containerRef.current, {\r\n      renderEdgeLabels: false,\r\n      enableEdgeHoverEvents: true,\r\n      enableEdgeClickEvents: false,\r\n      edgeProgramClasses: {\r\n        arrow: EdgeArrowProgram, // Используем программу для отрисовки стрелочек\r\n      },\r\n    });\r\n\r\n    sigmaInstanceRef.current = sigmaInstance; // Сохраняем экземпляр Sigma\r\n\r\n    // Настройка ForceAtlas2\r\n    const settings = forceAtlas2.inferSettings(graph);\r\n    settings.adjustSizes = true; // Учитываем размеры узлов\r\n    settings.scalingRatio = 50; // Увеличиваем масштаб\r\n    settings.gravity = 0.01; // Уменьшаем гравитацию для более равномерного распределения\r\n    settings.strongGravityMode = false; // Включаем сильную гравитацию\r\n\r\n    // Применяем ForceAtlas2 для динамического расположения узлов\r\n    forceAtlas2.assign(graph, { settings, iterations: 1000 }); // Увеличиваем количество итераций\r\n\r\n    // Обработка событий\r\n    sigmaInstance.on('clickNode', (event) => {\r\n      const node = event.node;\r\n      selectedNodeRef.current = node; // Сохраняем выбранный узел\r\n\r\n      // Выделяем связи и зависимые центры\r\n      const neighbors = graph.neighbors(node);\r\n      const edges = graph.edges(node);\r\n\r\n      // Затемняем все узлы и рёбра\r\n      graph.forEachNode((n) => {\r\n        graph.setNodeAttribute(n, 'hidden', true);\r\n      });\r\n      graph.forEachEdge((e) => {\r\n        graph.setEdgeAttribute(e, 'hidden', true);\r\n      });\r\n\r\n      // Подсвечиваем узел и его соседей\r\n      graph.setNodeAttribute(node, 'hidden', false);\r\n      graph.setNodeAttribute(node, 'highlighted', true);\r\n      neighbors.forEach((neighbor) => {\r\n        graph.setNodeAttribute(neighbor, 'hidden', false);\r\n        graph.setNodeAttribute(neighbor, 'highlighted', true);\r\n      });\r\n\r\n      // Подсвечиваем рёбра\r\n      edges.forEach((edge) => {\r\n        graph.setEdgeAttribute(edge, 'hidden', false);\r\n        graph.setEdgeAttribute(edge, 'highlighted', true);\r\n      });\r\n\r\n      sigmaInstance.refresh();\r\n    });\r\n\r\n    sigmaInstance.on('doubleClickNode', (event) => {\r\n      event.preventSigmaDefault();\r\n      const node = data.find((item) => item.id.toString() === event.node);\r\n      if (node) onCenterDoubleClick(node);\r\n    });\r\n\r\n    // Выделение связей при наведении на узел с задержкой\r\n    sigmaInstance.on('enterNode', (event) => {\r\n      // Очищаем предыдущий таймер\r\n      if (hoverTimeoutRef.current) {\r\n        clearTimeout(hoverTimeoutRef.current);\r\n      }\r\n\r\n      // Устанавливаем новый таймер\r\n      hoverTimeoutRef.current = setTimeout(() => {\r\n        const node = event.node;\r\n        const neighbors = graph.neighbors(node);\r\n        const edges = graph.edges(node);\r\n\r\n        // Затемняем все узлы и рёбра\r\n        graph.forEachNode((n) => {\r\n          graph.setNodeAttribute(n, 'hidden', true);\r\n        });\r\n        graph.forEachEdge((e) => {\r\n          graph.setEdgeAttribute(e, 'hidden', true);\r\n        });\r\n\r\n        // Подсвечиваем узел и его соседей\r\n        graph.setNodeAttribute(node, 'hidden', false);\r\n        graph.setNodeAttribute(node, 'highlighted', true);\r\n        neighbors.forEach((neighbor) => {\r\n          graph.setNodeAttribute(neighbor, 'hidden', false);\r\n          graph.setNodeAttribute(neighbor, 'highlighted', true);\r\n        });\r\n\r\n        // Подсвечиваем рёбра\r\n        edges.forEach((edge) => {\r\n          graph.setEdgeAttribute(edge, 'hidden', false);\r\n          graph.setEdgeAttribute(edge, 'highlighted', true);\r\n        });\r\n\r\n        sigmaInstance.refresh();\r\n      }, 300); // Задержка 300 мс\r\n    });\r\n\r\n    // Сброс выделения при уходе с узла\r\n    sigmaInstance.on('leaveNode', (event) => {\r\n      // Очищаем таймер\r\n      if (hoverTimeoutRef.current) {\r\n        clearTimeout(hoverTimeoutRef.current);\r\n      }\r\n\r\n      // Если узел не выбран, сбрасываем выделение\r\n      if (!selectedNodeRef.current) {\r\n        graph.forEachNode((n) => {\r\n          graph.setNodeAttribute(n, 'hidden', false);\r\n          graph.setNodeAttribute(n, 'highlighted', false);\r\n        });\r\n        graph.forEachEdge((e) => {\r\n          graph.setEdgeAttribute(e, 'hidden', false);\r\n          graph.setEdgeAttribute(e, 'highlighted', false);\r\n        });\r\n\r\n        sigmaInstance.refresh();\r\n      }\r\n    });\r\n\r\n    // Обработка клика в пустое пространство\r\n    sigmaInstance.on('clickStage', () => {\r\n      // Сбрасываем выделение всех узлов и рёбер\r\n      selectedNodeRef.current = null; // Сбрасываем выбранный узел\r\n      graph.forEachNode((n) => {\r\n        graph.setNodeAttribute(n, 'hidden', false);\r\n        graph.setNodeAttribute(n, 'highlighted', false);\r\n      });\r\n      graph.forEachEdge((e) => {\r\n        graph.setEdgeAttribute(e, 'hidden', false);\r\n        graph.setEdgeAttribute(e, 'highlighted', false);\r\n      });\r\n\r\n      sigmaInstance.refresh();\r\n    });\r\n\r\n    // Обновляем размеры Sigma при изменении размеров контейнера\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      for (const entry of entries) {\r\n        const { width, height } = entry.contentRect;\r\n        setDimensions({ width, height });\r\n        sigmaInstance.refresh();\r\n      }\r\n    });\r\n\r\n    if (containerRef.current) {\r\n      resizeObserver.observe(containerRef.current);\r\n    }\r\n\r\n    return () => {\r\n      sigmaInstance.kill();\r\n      resizeObserver.disconnect();\r\n      if (hoverTimeoutRef.current) {\r\n        clearTimeout(hoverTimeoutRef.current);\r\n      }\r\n    };\r\n  }, [data, onCenterClick, onCenterDoubleClick]);\r\n\r\n  // Функция для генерации динамического цвета на основе строки\r\n  const getColorBySchool = (school) => {\r\n    const colors = ['#FF6F61', '#6B5B95', '#88B04B', '#F7CAC9', '#92A8D1'];\r\n    const index = school?.length % colors.length || 0;\r\n    return colors[index];\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <div\r\n      ref={containerRef}\r\n      style={{\r\n        width: '100vw',\r\n        height: '100vh',\r\n        border: '1px solid #ccc',\r\n      }}\r\n    />\r\n    </div>\r\n    \r\n  );\r\n};\r\n\r\nexport default React.memo(SpiderWeb);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}